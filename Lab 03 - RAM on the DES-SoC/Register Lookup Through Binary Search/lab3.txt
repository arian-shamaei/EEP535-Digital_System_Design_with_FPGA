Lab  3  RAM  on  the  DE1-SoC 
1.  Learning  the  DE1-SoC  Memory  Blocks 1 1.1  RAM  structure 1 1.2  Quartus  Library  RAM  Module  Tutorial 2 1.3  Memory  Using  SystemVerilog  D-FlipFlops 4 1.4  Quartus  Library  RAM  Module  with  Independent  Read  and  Write  Tutorial 4 
2.  Algorithmic  State  Machine  with  Datapath  (ASMD) 6 2.1  Background 6 2.2  Bit  Counter 8 2.3  Binary  Search 8 Project  Design  Requirements: 10 Hint: 10 
Turn-In  Requirements 10 Report 10 Demo 10  
1.  Learning  the  DE1-SoC  Memory  Blocks  This  lab  introduces  FPGA  memory  architecture  and  the  design  of  algorithmic  digital  systems.  You  will  
learn
 
to
 
instantiate
 
on-chip
 
memory,
 
use
 
initialization
 
files,
 
and
 
apply
 
Algorithmic
 
State
 
Machine
 
with
 
Datapath
 
(ASMD)
 
design
 
methods
 
to
 
build
 
a
 
bit
 
counter
 
and
 
a
 
binary
 
search
 
engine.
 1.1  RAM  structure  The  FPGA  included  on  the  DE1-SoC  board  provides  dedicated  memory  resources:  397  total  
M10K
 
blocks,
 
each
 
containing
 
10240
 
memory
 
bits.
 
The
 
M10K
 
blocks
 
can
 
be
 
configured
 
to
 
implement
 
memories
 
of
 
various
 
sizes.
 
A
 
common
 
term
 
used
 
to
 
specify
 
the
 
size
 
of
 
a
 
memory
 
is
 
its
 
aspect
 
ratio,
 
which
 
gives
 
the
 
depth
 
(in
 
words)
 
and
 
the
 
width
 
(in
 
bits)
 
as
 
depth
 
and
 
width
.
 
In
 
this
 
lab,
 
we
 
will
 
use
 
an
 
aspect
 
ratio
 
of
 
32
 
x
 
4.
  Key  characteristics  of  memory  module:  ●  Width  –  the  number  of  bits  in  a  word  ●  Depth  –  the  number  words  in  the  module   There  are  two  important  features  of  the  M10K  blocks:  ●  They  include  registers  to  synchronize  all  the  input  and  output  signals  to  a  clock  input.  ●  They  have  separate  ports  for  writing  data  to  the  memory  and  reading  data  from  
the
 
memory.
  A  conceptual  diagram  of  the  Random-Access  Memory  (RAM)  module  that  we  want  to  implement  
is
 
shown
 
in
 
Figure
 
1a.
 
It
 
contains
 
32
 
four-bit
 
words
 
(i.e.,
 
rows)
 
that
 
are
 
accessed
 
using
 
a
 
five-bit
 
Address  port,  a  four-bit  bidirectional  Data  port,  and  a  Write  control  input.  However,  given  the  properties  of  the  M10K  blocks,  we  will  instead  implement  the  modified  32  x  4  RAM  module  shown  in  Figure  1b.  It  includes  registers  for  the  address,  data  input,  and  write  ports,  and  uses  a  separate  unregistered  data  output  port.     
 
Figure  1:  32  x  4  RAM  module    
1.2  Quartus  Library  RAM  Module  Tutorial  This  exercise  is  for  practice  only,  but  completing  it  will  significantly  help  you  succeed  in  the  later  design  tasks.   Commonly  used  logic  structures,  such  as  adders,  registers,  counters,  and  memories,  can  be  implemented  in  an  FPGA  chip  by  using  prebuilt  modules  that  are  provided  in  libraries.  In  this  exercise,  we  will  use  such  a  module  to  implement  the  memory  shown  in  Figure  1b.   1)  Get  a  library  RAM  module  from  the  IP  Catalog:  a)  Open  the  IP  Catalog  in  the  Quartus  menu  by  clicking  on  Tools  →  “IP  Catalog”.  b)  In  the  IP  Catalog  window,  expand  “Library”,  then  “Basic  Functions”,  then  “On  Chip  Memory”.  Then  double-click  “ RAM:  1-PORT ”.  

c)  In  the  “Save  IP  Variation”  dialog  box  that  opens,  append  the  text  “ram32x4.v”  to  
the
 
end
 
of
 
the
 
file
 
name
 
and
 
select
 
“Verilog”
 
as
 
the
 
file
 
type.
 
Then
 
click
 
“OK”
 
to
 
open
 
the
 
configuration
 
wizard.
 d)  In  the  configuration  window,  specify  the  4-bit  width  for  the  output  bus  and  32  
words
 
of
 
memory.
 
Then
 
select
 
the
 
“M10K”
 
radio
 
button
 
for
 
memory
 
block
 
type
 
and
 
“Single
 
clock”
 
for
 
the
 
clocking
 
method
 
before
 
clicking
 
“Next
 
>”.
 e)  Deselect  the  option  to  register  (i.e.,  placing  a  register  on)  the  ‘q’  output  port  so  
the
 
RAM
 
matches
 
the
 
unregistered
 
structure
 
in
 
Figure
 
1b.
 
Click
 
“Finish”
 
to
 
accept
 
the
 
defaults
 
for
 
the
 
rest
 
of
 
the
 
settings
 
in
 
the
 
Wizard.
 f)  Click  “Finish”  one  more  time  on  the  Summary  page  to  exit  the  Wizard.  If  
prompted,
 
add
 
the
 
new
 
Quartus
 
Prime
 
IP
 
File
 
to
 
your
 
project
 
by
 
clicking
 
“Yes”.
  2)  Go  to  “Files”  in  the  Project  Navigator  window  and  open  ram32x4.v  (nested  
under
 
ram32x4.qip)
 
to
 
examine
 
it.
 
It
 
defines
 
the
 
following
 
module:
 
 
  
 3)  Create  a  new  top-level  SystemVerilog  file  and  instantiate  the  ram32x4  module,  using  
appropriate
 
input
 
and
 
output
 
signals
 
for
 
the
 
memory
 
ports
 
as
 
shown
 
in
 
Figure
 
1b.
  module  DE1_SoC  (KEY,  LEDR,  SW,CLOCK_50);  output  logic  [9:0]  LEDR;  
input
 
logic
 
[3:0]
 
KEY;
 
input
 
logic
 
[9:0]
 
SW;
 
input
 
logic
 
CLOCK_50;
  ram32x4  RAM  (.address(SW[4:0]),.clock(CLOCK_50),  .data(SW[8:5]),.wren(SW[9]),.q(LEDR[3:0]));   endmodule  

4)  Create  the  testbench  module  for  the  circuit  in  ModelSim  and  ensure  that  you  can  read  
and
 
write
 
data
 
in
 
the
 
memory.
 
Once
 
you
 
compile
 
your
 
circuit,
 
various
 
parts
 
of
 
the
 
Compilation
 
Report
 
will
 
indicate
 
that
 
the
 
RAM
 
circuit
 
is
 
implemented
 
using
 
128
 
bits
 
in
 
one
 
of
 
the
 
FPGA
 
memory
 
blocks.
  
   
1.3  Memory  Using  SystemVerilog  D-FlipFlops  Instead  of  creating  a  memory  module  by  using  the  IP  Catalog,  we  can  implement  the  required  
memory
 
by
 
specifying
 
its
 
structure
 
in
 
SystemVerilog
 
code
 
as
 
a
 
multidimensional
 
array.
 
A
 
32
 
x
 
4
 
array,
 
which
 
has
 
32
 
words
 
with
 
4
 
bits
 
per
 
word,
 
can
 
be
 
declared
 
by
 
the
 
statement:
  logic  [3:0]  memory_array  [31:0];   1)  Write  a  SystemVerilog  module  (including  the  line  above  as  a  local  variable)  that  provides  
the
 
necessary
 
functionality,
 
including
 
the
 
ability
 
to
 
load
 
the
 
RAM
 
and
 
read
 
its
 
contents
 
in
 
the
 
DE1_SoC
 
module.
 ( NOTE :  The  write/read  behavior  only  happens  at  the  posedge  of  the  clock.)  a)  Use  switches  SW3–SW0  to  specify  DataIn  and  switches  SW8–SW4  to  specify  
Address.
 b)  Use  SW9  as  the  Write  signal  and  KEY0  as  the  Clock  input.  c)  Display  the  Address  value  (in  hex)  on  HEX5–HEX4,  the  DataIn  value  on  
HEX2,
 
and
 
DataOut
 
on
 
HEX0.
 2)  Create  a  testbench  for  all  your  modules.  3)  Assign  the  pins  on  the  FPGA  to  connect  to  the  switches  and  the  7-segment  displays.  4)  Compile  the  circuit  and  download  it  into  the  DE1-SoC  board  to  test  its  functionality.    
1.4  Quartus  Library  RAM  Module  with  Independent  Read  and  Write  Tutorial  1)  Generate  the  desired  memory  module  from  the  IP  Catalog  by  using  the  “RAM:  
2-PORT”
 
module
 
and
 
call
 
the
 
file
 
ram32x4port2.v.
 a)  Under  “How  will  you  be  using  the  dual  port  RAM?”,  select  “With  one  read  port  
and
 
one
 
write
 
port”
 
and
 
then
 
“Next
 
>”.
 b)  In  the  configuration  window,  specify  the  4-bit  width  for  the  output  bus  and  32  
words
 
of
 
memory.
 
Then
 
select
 
the
 
“M10K”
 
radio
 
button
 
for
 
memory
 
block
 
type
 
and
 
“Single
 
clock”
 
for
 
the
 
clocking
 
method
 
before
 
clicking
 
“Next
 
>”.
 

c)  Now,  deselect  the  check  box  for  registering  (i.e.,  placing  a  register  on)  the  “'q'  output  port”.  This  creates  a  RAM  module  that  matches  the  structure  in  Figure  1b.  d)  Under  “Mixed  Port  Read-During-Write  for  Single  Input  Clock  RAM”,  select  “I  do  not  care  (The  outputs  will  be  undefined)”.  ●  This  setting  specifies  that  it  does  not  matter  whether  the  memory  outputs  the  new  data  being  written,  or  the  old  data  previously  stored,  in  the  case  then  the  write  and  read  addresses  are  the  same  during  a  write  operation.  e)  Under  “Do  you  want  to  specify  the  initial  contents  of  memory?”,  select  “Yes,  use  this  file  for  the  memory  content  data”  and  specify  the  filename  “ram32x4.mif”  This  memory  initialization  file  (MIF)  allows  us  to  initialize  our  RAM  to  specific  values  that  are  loaded  when  the  circuit  is  programmed  into  the  FPGA  chip.  You  will  create  this  MIF  file  in  Step  3.  f)  Finish  the  Wizard  and  then  examine  the  generated  memory  module  in  ram32x4port2.v.  2)  Create  your  MIF  file  ram32x4.mif:  a)  In  the  Quartus  menu,  go  to  File  →  New…  and  then  select  “Memory  Initialization  File”.  b)  Specify  32  words  and  word  size  of  4.  c)  Manually  fill  the  grid  with  the  values  you  want  to  place  in  each  memory  address.  These  values  can  be  any  4-bit  number  as  long  as  they  aren’t  all  the  same.  ●  If  helpful,  the  View  menu  will  let  you  adjust  the  number  of  cells  per  row  displayed  and  the  address  and  memory  radices.  d)  Save  the  MIF  file  as  ram32x4.mif.  You  can  also  manually  edit  this  file  in  a  text  editor.  3)  Modify  the  DE1-SoC  module  that  instantiates  your  new  memory.  You  are  expected  to  create  a  testbench  for  all  your  modules  and  simulate  them  before  downloading  your  design  to  the  FPGA.  a)  Use  SW8–SW4  and  SW3–SW0  to  specify  the  write  address  and  write  data,  respectively.  Use  SW9  as  the  write  enable  (wren).  Display  (in  hex)  the  write  address  on  HEX5–HEX4  and  the  write  data  on  HEX1.  b)  Use  the  50  MHz  clock,  CLOCK_50  to  synchronize  the  system  and  use  KEY3  as  a  reset  signal.  Ensure  you  properly  synchronize  the  switch  inputs  to  the  50  MHz  clock  signal.  c)  Use  a  counter  to  cycle  through  read  addresses  with  KEY0  as  the  Clock  input.  Display  (in  hex)  the  read  address  on  HEX3–HEX2  and  the  4-bit  word  content  on  HEX0.   module  counter  (q,  reset,  clk);  output  logic  [4:0]  q;  input  logic  reset,  clk;  always_ff  @(posedge  clk)  begin  if  (reset)  q  <=  0;  //  On  reset,  set  to  0  else  
q  <=  q+1;  //  Otherwise  out  =  d  end  endmodule   4)  Test  your  circuit  and  verify  that  the  initial  contents  of  the  memory  match  your  ram32x4.mif  file.  Make  sure  that  you  can  independently  write  data  to  any  address  by  using  the  slide  switches.  
Having  implemented  and  tested  on-chip  RAM,  you  will  now  apply  these  memory  concepts  within  algorithmic  designs  using  the  ASMD  methodology.  
2.  Algorithmic  State  Machine  with  Datapath  (ASMD)  
Credit  to  Intel  for  the  following  lesson   
2.1  Background  Algorithmic  State  Machine  (ASM)  charts  are  a  design  tool  that  allow  the  specification  of  digital  systems  in  a  form  similar  to  a  flow  chart.  An  example  of  an  ASM  chart  is  shown  below.  It  represents  a  circuit  that  counts  the  number  of  bits  set  to  1  in  an  n-bit  input  A.   The  rectangular  boxes  in  this  diagram  represent  the  states  of  the  digital  system,  and  actions  specified  inside  of  a  state  box  occur  on  each  active  clock  edge  in  this  state.  Transitions  between  states  are  specified  by  arrows.  The  diamonds  in  the  ASM  chart  represent  conditional  tests,  and  the  ovals  represent  actions  taken  only  if  the  corresponding  conditions  are  either  true  (on  an  arrow  labeled  1)  or  false  (on  an  arrow  labeled  0).  
   In  this  ASM  chart,  state  S1  is  the  initial  state.  In  this  state  the  result  is  initialized  to  0,  and  data  is  loaded  into  a  register  A,  until  a  start  signal,  s,  is  asserted.  The  ASM  chart  then  transitions  to  state  S2,  where  it  increments  the  result  to  count  the  number  of  1’s  in  register  A.  Since  state  S2  specifies  a  shifting  operation,  then  A  should  be  implemented  as  a  shift  register.  Also,  since  the  result  is  incremented,  then  this  variable  should  be  implemented  as  a  counter.  When  register  A  contains  0  the  ASM  chart  transitions  to  state  S3,  where  it  sets  an  output  Done  =  1  and  waits  for  the  signal  s  to  be  deasserted.   A  key  distinction  between  ASM  charts  and  flow  charts  is  a  concept  known  as  implied  timing.  The  implied  timing  specifies  that  all  actions  associated  with  a  given  state  take  place  only  when  the  system  is  in  that  state  when  an  active  clock  edge  occurs.  For  example,  when  the  system  is  in  state  S1  and  the  start  signal  s  becomes  1,  then  the  next  active  clock  edge  performs  the  following  actions:  initializes  result  to  0,  and  transitions  to  state  S2.  The  action  right-shift  A  does  not  happen  yet,  because  the  system  is  not  yet  in  state  S2.  For  each  active  clock  cycle  in  state  S2,  the  actions  highlighted  in  Figure  1  take  place,  as  follows:  increment  result  if  bit  a0  =  1,  change  to  state  S3  if  A  =  0  (or  else  remain  in  state  S2),  and  shift  A  to  the  right.  

The  implementation  of  the  bit  counting  circuit  includes  the  counter  to  store  the  result  and  the  shift  register  A,  as  well  as  a  finite  state  machine.  The  FSM  is  often  referred  to  as  the  control  circuit,  and  the  other  components  as  the  datapath  circuit.   
2.2  Bit  Counter  Implement  the  bit-counting  circuit  given  by  the  ASMD  chart  above  (in  section  2.1)  in  SystemVerilog  to  run  on  the  DE1-SoC  board,  combining  the  necessary  datapath  components  and  a  control  circuit  FSM.  -  The  inputs  to  your  circuit  should  consist  of  an  8-bit  input  ( A )  connected  to  switches  SW7–SW0,  a  synchronous  reset  connected  to  KEY0,  and  a  start  signal  ( S )  connected  to  switch  SW9.  -  Use  the  50  MHz  clock  signal  provided  on  the  board  as  the  clock  input  for  your  circuit.  Be  sure  to  synchronize  S  to  the  clock.  -  Display  the  number  of  S  counted  in  A  on  the  7-segment  display  HEX0  and  signal  that  the  algorithm  is  finished  by  lighting  up  LEDR9.   If  SW[7:0]  =  8’b01001100,  HEX0  would  display  3  once  the  algorithm  is  in  the  ‘done’  state.   
2.3  Binary  Search  You  will  implement  a  binary  search  circuit  that  locates  an  8-bit  target  value  A  in  a  sorted  32-element  array  once  Start  is  enabled.  The  block  diagram  for  the  circuit  is  shown  in  Figure  4.   The  binary  search  algorithm  works  on  a  sorted  array.  Rather  than  comparing  each  value  in  the  array  to  the  one  being  sought,  we  first  look  at  the  middle  element  and  compare  the  sought  value  to  the  middle  element.  If  the  middle  element  has  a  greater  value,  then  we  know  that  the  value  we  seek  would  be  in  the  first  half  of  the  array.  Otherwise,  the  value  we  seek  would  be  in  the  second  half  of  the  array.  By  applying  this  approach  recursively,  we  can  complete  our  search  in  many  fewer  steps.  
 Figure  4:  Block  diagram  for  the  binary  search  algorithm  circuit.  
 
Figure  5:  32  ×  8  RAM  with  registered  inputs  for  the  binary  search  algorithm  circuit.   In  this  circuit,  the  array,  which  you  can  assume  has  a  fixed  size  of  32  elements,  is  stored  in  a  memory  module  that  is  implemented  inside  the  FPGA.  A  diagram  of  the  memory  module  that  we  need  to  create  is  depicted  in  Figure  5.  This  memory  should  contain  a  sorted  collection  of  8-bit  integers.   The  input  A  should  be  specified  on  switches  SW7–SW0,  Start  on  SW9  and  Reset  on  KEY0.  Your  circuit  should  produce  a  5-bit  output  Loc ,  which  specifies  the  address  in  the  memory  where  the  number  A  is  located,  and  a  signal  Found  that  should  be  high  if  A  was  found  and  low  otherwise.  Display  Loc  in  hex  on  HEX1–HEX0  and  Found  on  LEDR9,  if  found.  

Project  Design  Requirements: 1.  An  ASMD  chart  for  the  binary  search  algorithm  2.  The  control  path  FSM  and  datapath  circuits  must  be  contained  within  different  modules  3.  Your  memory  must  be  a  generated  Quartus  Library  Memory  Block  4.  Your  memory  must  be  32  words,  and  words  must  be  8  bits  wide  5.  Your  memory  must  be  initialized  by  a  file  of  your  creation  called  my_sorted_array.mif  a.  This  file  should  be  filled  with  an  ordered  set  of  8-bit  integers  (of  your  choice)   Hint: 
The  RAM  output  updates  one  clock  cycle  after  a  new  address  is  applied.  Design  your  control  logic  to  wait  for  valid  data  before  proceeding.  
 
Figure  6:  The  value  from  the  RAM   If  everything  seems  to  be  working  in  simulation  but  not  on  your  board,  we  recommend  using  SignalTap  II  to  probe  the  data  loaded  into  the  RAM  and  other  various  signals  of  your  circuit.   
Turn-In  Requirements   Report  (Template) 1.  Memory  Using  SystemVerilog  D-FlipFlops  (1.3)  a.  ModelSim  simulation  screenshot(s)  for  each  module  written  (including  DE1_SoC)  2.  Quartus  Library  RAM  Module  with  Independent  Read  and  Write  Tutorial  (1.4)  a.  ModelSim  simulation  screenshot(s)  for  each  module  written  (including  DE1_SoC)  b.  Screenshot  of  SignalTap  II  in  use  (can  be  of  any  data  as  long  as  it  shows  your  ability  to  open  and  use  SignalTap  II)  3.  Bit  Counter  a.  ModelSim  simulation  screenshot(s)  for  each  module  written  (including  DE1_SoC)  4.  Binary  Search  a.  ASMD  chart  for  the  binary  search  algorithm  b.  ModelSim  simulation  screenshot(s)  for  each  module  written  (including  DE1_SoC)   
Demo 1.  Demo  with  TA:  Memory  Using  SystemVerilog  D-FlipFlops  project  (1.3)  2.  Demo  with  TA:  Quartus  Library  RAM  Module  with  Independent  Read  and  Write  Tutorial  (1.4)  3.  Demo  with  TA:  Bit  Counter  

4.  Demo  with  TA:  Binary  Search   
 
Canvas  Submission  
1.  Zip  file  of  all  code  (make  sure  to  comment  your  code!)  a.  1.3  -  32x4  Memory  Array  b.  1.4  -  Dual  Port  RAM  c.  2.2  -  Bit  Counter  d.  2.3  -  Binary  Search  2.  Report  as  a  .pdf  a.  Must  have  all  components  mentioned  in  “Turn-In  Requirements”  b.  Give  information  about  approach  and  implementation  c.  Take  about  any  challenges,  weird  bugs,  etc.  that  were  present  